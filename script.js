// Configuration du jeu de piste - Version Test
const GAME_CONFIG = {
    // Centre de la zone de test
    center: [49.0928, 6.1907],
    zoom: 16,
    // Distance en m√®tres pour d√©clencher un indice
    proximityThreshold: 50,
    // Cl√© API OpenRouteService
    orsApiKey: 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjgxYzE2ZTJjN2NiODQ3YjY5ZTdhYjU5MzdjNTNjMjlmIiwiaCI6Im11cm11cjY0In0=',
    // Points d'int√©r√™t avec coordonn√©es et indices
    checkpoints: [] // Maintenant charg√©s depuis Firebase via l'admin
};

// Variables globales
let map;
let userMarker;
let userPosition = null;
let foundCheckpoints = [];
let checkpointMarkers = [];
let unlockedCheckpoints = [0]; // Le lobby est toujours accessible
let currentRoute = null; // Route actuelle affich√©e
let routeControl = null; // Contr√¥le de navigation
let currentTeam = null; // √âquipe connect√©e
let currentTeamId = null; // ID unique de l'√©quipe dans Firebase
let currentDestination = null; // Destination actuelle pour recalcul auto
let lastRecalculateTime = 0; // Timestamp du dernier recalcul pour √©viter les spams
let firebaseService = null; // Service Firebase
let isMapInitialized = false; // V√©rifier si la carte est d√©j√† initialis√©e
let isGameStarted = false; // V√©rifier si le jeu est d√©j√† d√©marr√©

// Fonction pour d√©coder une polyline encod√©e
function decodePolyline(encoded) {
    const poly = [];
    let index = 0;
    const len = encoded.length;
    let lat = 0;
    let lng = 0;

    while (index < len) {
        let b;
        let shift = 0;
        let result = 0;
        do {
            b = encoded.charCodeAt(index++) - 63;
            result |= (b & 0x1f) << shift;
            shift += 5;
        } while (b >= 0x20);
        const dlat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
        lat += dlat;

        shift = 0;
        result = 0;
        do {
            b = encoded.charCodeAt(index++) - 63;
            result |= (b & 0x1f) << shift;
            shift += 5;
        } while (b >= 0x20);
        const dlng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
        lng += dlng;

        poly.push([lng / 1e5, lat / 1e5]);
    }
    return poly;
}

// Configuration des √©quipes
const TEAMS = {
    team1: {
        name: "üî¥ √âquipe Rouge",
        color: "#e74c3c",
        route: [1, 2] // Ordre des checkpoints pour cette √©quipe
    },
    team2: {
        name: "üîµ √âquipe Bleue", 
        color: "#3498db",
        route: [2, 1] // Ordre diff√©rent pour cette √©quipe
    },
    team3: {
        name: "üü¢ √âquipe Verte",
        color: "#27ae60", 
        route: [1, 2] // M√™me que rouge pour l'instant
    },
    team4: {
        name: "üü° √âquipe Jaune",
        color: "#f1c40f",
        route: [2, 1] // M√™me que bleue pour l'instant
    }
};

// Initialisation de l'application
document.addEventListener('DOMContentLoaded', function() {
    initializeApp();
});

function initializeApp() {
    // √âviter la double initialisation
    if (window.appInitialized) {
        console.log('‚ö†Ô∏è App d√©j√† initialis√©e, on ignore');
        return;
    }
    window.appInitialized = true;
    
    console.log('üöÄ Initialisation du jeu de piste...');
    
    // Initialiser Firebase Service
    if (window.firebaseService) {
        firebaseService = window.firebaseService;
        console.log('‚úÖ Firebase Service initialis√©');
    } else {
        console.warn('‚ö†Ô∏è Firebase Service non disponible - mode hors ligne');
    }
    
    // V√©rifier si une √©quipe est connect√©e
    checkTeamLogin();
}

function checkTeamLogin() {
    // V√©rifier si une √©quipe est d√©j√† connect√©e
    const savedTeamId = localStorage.getItem('currentTeamId');
    
    if (savedTeamId) {
        // √âquipe d√©j√† connect√©e, charger ses donn√©es
        loadTeamData(savedTeamId);
    } else {
        // Pas d'√©quipe connect√©e, afficher le modal de connexion
        showTeamLoginModal();
    }
}

function showTeamLoginModal() {
    const modal = document.getElementById('user-login-modal'); // On garde le m√™me modal pour l'instant
    modal.style.display = 'block';
    
    // Configurer les √©v√©nements de connexion
    setupLoginEvents();
}

function setupLoginEvents() {
    const userIdInput = document.getElementById('user-id');
    const passwordInput = document.getElementById('user-password');
    const loginBtn = document.getElementById('login-btn');
    
    // Activer/d√©sactiver le bouton selon les champs
    function updateLoginButton() {
        const hasUserId = userIdInput.value.trim().length > 0;
        const hasPassword = passwordInput.value.length > 0;
        loginBtn.disabled = !(hasUserId && hasPassword);
    }
    
    userIdInput.addEventListener('input', updateLoginButton);
    passwordInput.addEventListener('input', updateLoginButton);
    
    // Connexion avec Enter
    [userIdInput, passwordInput].forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !loginBtn.disabled) {
                handleUserLogin();
            }
        });
    });
    
    // Connexion avec le bouton
    loginBtn.addEventListener('click', handleUserLogin);
}

// Gestion de la connexion √©quipe (plus de users !)
async function handleUserLogin() {
    const teamName = document.getElementById('user-id').value.trim();
    const password = document.getElementById('user-password').value;
    const errorDiv = document.getElementById('login-error');
    const loadingDiv = document.getElementById('login-loading');
    
    try {
        // Afficher le loading
        errorDiv.style.display = 'none';
        loadingDiv.style.display = 'block';
        
        // V√©rifier les identifiants de l'√©quipe dans Firebase
        const team = await firebaseService.authenticateTeam(teamName, password);
        
        if (team) {
            // Connexion r√©ussie
            currentTeam = team;
            currentTeamId = team.id;
            localStorage.setItem('currentTeamId', team.id);
            
            // Cacher le modal et d√©marrer le jeu
            document.getElementById('user-login-modal').style.display = 'none';
            
            // Charger les donn√©es de l'√©quipe
            await loadTeamGameData();
            
            showNotification(`Bienvenue √©quipe ${team.name} !`, 'success');
            
        } else {
            showLoginError('Nom d\'√©quipe ou mot de passe incorrect');
        }
        
    } catch (error) {
        console.error('‚ùå Erreur de connexion √©quipe:', error);
        showLoginError('Erreur de connexion. Veuillez r√©essayer.');
    } finally {
        loadingDiv.style.display = 'none';
    }
}

// Charger les donn√©es √©quipe depuis Firebase
async function loadTeamData(teamId) {
    try {
        const team = await firebaseService.getTeam(teamId);
        if (team) {
            currentTeam = team;
            currentTeamId = teamId;
            await loadTeamGameData();
        } else {
            // √âquipe non trouv√©e, d√©connecter
            localStorage.removeItem('currentTeamId');
            showTeamLoginModal();
        }
    } catch (error) {
        console.error('‚ùå Erreur chargement √©quipe:', error);
        localStorage.removeItem('currentTeamId');
        showTeamLoginModal();
    }
}

// Charger les donn√©es de jeu de l'√©quipe
async function loadTeamGameData() {
    if (!currentTeam) {
        console.error('‚ùå Aucune √©quipe actuelle pour charger les donn√©es de jeu');
        return;
    }
    
    try {
        // V√©rifier que l'√©quipe a une route valide
        if (!currentTeam.route || currentTeam.route.length === 0) {
            console.error('‚ùå L\'√©quipe n\'a pas de parcours d√©fini:', currentTeam);
            showNotification('‚ùå Parcours non configur√© pour votre √©quipe. Contactez l\'administrateur.', 'error');
            return;
        }
        
        // Restaurer la progression avec des valeurs par d√©faut s√ªres
        foundCheckpoints = currentTeam.foundCheckpoints || [];
        unlockedCheckpoints = currentTeam.unlockedCheckpoints || [0];
        
        // V√©rifier la coh√©rence des donn√©es
        if (!Array.isArray(foundCheckpoints)) foundCheckpoints = [];
        if (!Array.isArray(unlockedCheckpoints)) unlockedCheckpoints = [0];
        
        // S'assurer que le lobby (0) est toujours d√©bloqu√©
        if (!unlockedCheckpoints.includes(0)) {
            unlockedCheckpoints.unshift(0);
        }
        
        // Afficher les infos de l'√©quipe
        showTeamInfo();
        
        // D√©marrer le jeu
        startGame();
        
        // D√©marrer la synchronisation temps r√©el avec l'√©quipe
        startTeamSync();
        
        console.log(`‚úÖ √âquipe ${currentTeam.name} connect√©e`, {
            foundCheckpoints,
            unlockedCheckpoints,
            teamRoute: currentTeam.route
        });
        
    } catch (error) {
        console.error('‚ùå Erreur lors du chargement des donn√©es de jeu:', error);
        showNotification('‚ùå Erreur de chargement. Rechargez la page.', 'error');
    }
}

// Afficher les informations √©quipe
function showTeamInfo() {
    const teamInfo = document.getElementById('team-info');
    const currentTeamSpan = document.getElementById('current-team');
    
    if (currentTeam && teamInfo && currentTeamSpan) {
        currentTeamSpan.textContent = `√âquipe ${currentTeam.name}`;
        currentTeamSpan.style.color = currentTeam.color || '#3498db';
        teamInfo.style.display = 'block';
    }
}

// Afficher une erreur de connexion
function showLoginError(message) {
    const errorDiv = document.getElementById('login-error');
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
    
    // Vider les champs
    document.getElementById('user-id').value = '';
    document.getElementById('user-password').value = '';
}

// Fonction supprim√©e - doublon avec la fonction showTeamInfo() ligne 270

function startGame() {
    // V√©rifier si le jeu est d√©j√† d√©marr√©
    if (isGameStarted) {
        console.log('‚ö†Ô∏è Jeu d√©j√† d√©marr√©, on ignore');
        return;
    }
    
    // Initialiser la carte
    initializeMap();
    
    // Demander la g√©olocalisation
    requestGeolocation();
    
    // Configurer les √©v√©nements
    setupEventListeners();
    
    // Synchroniser et ajouter les checkpoints depuis Firebase
    syncCheckpoints();
    
    // Mettre √† jour l'interface
    updateUI();
    
    isGameStarted = true;
}

function initializeMap() {
    console.log('üó∫Ô∏è Initialisation de la carte...');
    
    // V√©rifier si la carte est d√©j√† initialis√©e
    if (isMapInitialized) {
        console.log('‚ö†Ô∏è Carte d√©j√† initialis√©e, on ignore');
        return;
    }
    
    // Cr√©er la carte centr√©e sur Turin
    map = L.map('map').setView(GAME_CONFIG.center, GAME_CONFIG.zoom);
    isMapInitialized = true;
    
    // Ajouter les tuiles OpenStreetMap (gratuit)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors',
        maxZoom: 19
    }).addTo(map);
    
    // Personnaliser les contr√¥les
    map.zoomControl.setPosition('bottomright');
    
    console.log('‚úÖ Carte initialis√©e avec succ√®s');
}

function requestGeolocation() {
    console.log('üìç Demande de g√©olocalisation...');
    
    if (!navigator.geolocation) {
        showNotification('G√©olocalisation non support√©e par votre navigateur', 'error');
        updateStatus('G√©olocalisation non disponible');
        return;
    }
    
    updateStatus('Localisation en cours...');
    
    const options = {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 2000  // Rafra√Æchissement plus fr√©quent (2 secondes)
    };
    
    navigator.geolocation.getCurrentPosition(
        onLocationSuccess,
        onLocationError,
        options
    );
    
    // Surveiller la position en continu
    navigator.geolocation.watchPosition(
        onLocationUpdate,
        onLocationError,
        options
    );
}


function onLocationSuccess(position) {
    console.log('‚úÖ Position obtenue:', position.coords);
    
    userPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy
    };
    
    updateUserMarker();
    updateStatus('Position trouv√©e !');
    updateCoordinatesDisplay();
    checkProximityToCheckpoints();
    updateHint();
    
    showNotification('Position d√©tect√©e avec succ√®s !');
}

function getNextAccessibleCheckpoint() {
    return GAME_CONFIG.checkpoints.find(cp => {
        const isFound = foundCheckpoints.includes(cp.id);
        const isUnlocked = unlockedCheckpoints.includes(cp.id);
        const isAccessible = !cp.locked || isUnlocked;
        return !isFound && isAccessible;
    });
}

function getNextCheckpointForTeam() {
    if (!currentTeam || !currentTeam.route) return null;
    
    const teamRoute = currentTeam.route;
    const nonLobbyFound = foundCheckpoints.filter(id => {
        const cp = GAME_CONFIG.checkpoints.find(c => c.id === id);
        return cp && !cp.isLobby;
    });
    
    // D√©terminer quel est le prochain checkpoint dans l'ordre de l'√©quipe
    // On commence √† l'index 1 pour ignorer le lobby (index 0)
    const nextIndex = nonLobbyFound.length + 1;
    
    if (nextIndex < teamRoute.length) {
        return teamRoute[nextIndex];
    }
    
    return null; // Tous les checkpoints sont termin√©s
}

function getTeamColor() {
    return currentTeam?.color || '#3498db';
}

// Fonction pour mettre √† jour la progression sur la route (grignotage + recalcul auto)
function updateRouteProgress() {
    if (!currentRoute || !userPosition) {
        console.log('‚ö†Ô∏è updateRouteProgress: pas de route ou position', {currentRoute: !!currentRoute, userPosition: !!userPosition});
        return;
    }
    
    console.log('üîÑ Mise √† jour progression GPS...');
    
    const userLatLng = L.latLng(userPosition.lat, userPosition.lng);
    const progressThreshold = 20; // Distance en m√®tres pour consid√©rer qu'on a "mang√©" un segment
    const recalculateThreshold = 50; // Distance en m√®tres pour recalculer la route
    
    // R√©cup√©rer les coordonn√©es de la route
    const routeCoords = [];
    currentRoute.eachLayer(function(layer) {
        if (layer.feature && layer.feature.geometry && layer.feature.geometry.coordinates) {
            layer.feature.geometry.coordinates.forEach(coord => {
                routeCoords.push(L.latLng(coord[1], coord[0])); // Inverser lng/lat
            });
        }
    });
    
    if (routeCoords.length === 0) return;
    
    // Trouver le point le plus proche sur la route
    let closestDistance = Infinity;
    let closestIndex = 0;
    
    routeCoords.forEach((coord, index) => {
        const distance = userLatLng.distanceTo(coord);
        if (distance < closestDistance) {
            closestDistance = distance;
            closestIndex = index;
        }
    });
    
    // Si on est assez proche, "manger" la partie de route d√©j√† parcourue
    if (closestDistance < progressThreshold && closestIndex > 0) {
        const remainingCoords = routeCoords.slice(closestIndex);
        
        if (remainingCoords.length > 1) {
            // Supprimer l'ancienne route
            map.removeLayer(currentRoute);
            
            // Cr√©er une nouvelle route avec seulement la partie restante
            const remainingGeoJSON = {
                type: "Feature",
                geometry: {
                    type: "LineString",
                    coordinates: remainingCoords.map(coord => [coord.lng, coord.lat])
                }
            };
            
            currentRoute = L.geoJSON(remainingGeoJSON, {
                style: {
                    color: getTeamColor(),
                    weight: 5,
                    opacity: 0.8,
                    dashArray: '10, 5'
                }
            }).addTo(map);
        }
    }
    // Si on est trop loin du trajet, recalculer automatiquement
    else if (closestDistance > recalculateThreshold && currentDestination) {
        const now = Date.now();
        const minRecalculateInterval = 10000; // Minimum 10 secondes entre recalculs
        
        if (now - lastRecalculateTime > minRecalculateInterval) {
            console.log(`üîÑ Recalcul automatique - Distance du trajet: ${Math.round(closestDistance)}m`);
            showNotification('üîÑ Recalcul du trajet GPS...');
            lastRecalculateTime = now;
            
            // Recalculer la route vers la m√™me destination
            setTimeout(() => {
                calculateRoute(userPosition, currentDestination);
            }, 1000);
        }
    }
}

function onLocationUpdate(position) {
    userPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy
    };
    
    updateUserMarker();
    updateCoordinatesDisplay();
    checkProximityToCheckpoints();
    
    // Mettre √† jour la route si elle existe (grignotage)
    if (currentRoute) {
        updateRouteProgress();
    }
}

function onLocationError(error) {
    console.error('‚ùå Erreur de g√©olocalisation:', error);
    
    let message = 'Erreur de g√©olocalisation';
    switch(error.code) {
        case error.PERMISSION_DENIED:
            message = 'G√©olocalisation refus√©e. Veuillez autoriser l\'acc√®s √† votre position.';
            break;
        case error.POSITION_UNAVAILABLE:
            message = 'Position indisponible. V√©rifiez votre connexion.';
            break;
        case error.TIMEOUT:
            message = 'D√©lai de g√©olocalisation d√©pass√©.';
            break;
    }
    
    updateStatus(message);
    showNotification(message, 'error');
}

function updateUserMarker() {
    if (!userPosition) return;
    
    const userLatLng = [userPosition.lat, userPosition.lng];
    
    if (userMarker) {
        userMarker.setLatLng(userLatLng);
    } else {
        // Cr√©er un marqueur personnalis√© pour l'utilisateur
        const userIcon = L.divIcon({
            className: 'user-marker',
            html: 'üìç',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        userMarker = L.marker(userLatLng, { icon: userIcon })
            .addTo(map)
            .bindPopup('Votre position actuelle');
    }
    
    // Centrer la carte sur l'utilisateur (seulement la premi√®re fois)
    if (!map.hasUserCentered) {
        map.setView(userLatLng, GAME_CONFIG.zoom);
        map.hasUserCentered = true;
    }
}

function addCheckpointsToMap() {
    console.log('üìç Ajout des checkpoints sur la carte...');
    
    GAME_CONFIG.checkpoints.forEach(checkpoint => {
        const isFound = foundCheckpoints.includes(checkpoint.id);
        const isUnlocked = unlockedCheckpoints.includes(checkpoint.id);
        const isLocked = checkpoint.locked && !isUnlocked;
        
        // Ne pas afficher les points verrouill√©s sur la carte
        if (isLocked) {
            // Stocker le checkpoint pour l'ajouter plus tard
            checkpointMarkers.push({
                id: checkpoint.id,
                marker: null,
                circle: null,
                checkpoint: checkpoint,
                hidden: true
            });
            return;
        }
        
        // Ajouter le cercle de proximit√© (buffer de 50m)
        const circle = L.circle(checkpoint.coordinates, {
            color: isFound ? '#27ae60' : '#3498db',
            fillColor: isFound ? '#27ae60' : '#3498db',
            fillOpacity: 0.1,
            radius: GAME_CONFIG.proximityThreshold,
            weight: 2,
            opacity: 0.6
        }).addTo(map);
        
        let markerClass = 'checkpoint-marker';
        if (isFound) markerClass += ' found';
        
        const markerIcon = L.divIcon({
            className: markerClass,
            html: checkpoint.emoji,
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        
        // Cr√©er le contenu du popup
        let popupContent = `
            <div style="text-align: center;">
                <h3>${checkpoint.emoji} ${checkpoint.name}</h3>
                <p>${isFound ? '‚úÖ D√©couvert !' : checkpoint.isLobby ? 'üè† Lobby' : 'üîç √Ä d√©couvrir'}</p>
                ${!isFound ? `<p><em>${checkpoint.hint}</em></p>` : ''}
                <p><small>Zone de d√©clenchement: ${GAME_CONFIG.proximityThreshold}m</small></p>
        `;
        
        // Ajouter le bouton GPS pour tous les points visibles
        if (userPosition) {
            let buttonText = 'üß≠ Calculer l\'itin√©raire GPS';
            let targetId = checkpoint.id;
            
            // Tous les points (y compris le lobby) ont un bouton GPS vers eux-m√™mes
            if (checkpoint.isLobby) {
                buttonText = 'üß≠ GPS vers Lobby';
            }
            
            popupContent += `
                <br>
                <button onclick="calculateRouteFromPopup(${targetId})" 
                        style="background: linear-gradient(135deg, ${getTeamColor()} 0%, ${getTeamColor()} 100%); 
                               color: white; border: none; padding: 0.5rem 1rem; 
                               border-radius: 20px; font-size: 0.9rem; cursor: pointer; 
                               margin-top: 0.5rem;">
                    ${buttonText}
                </button>
            `;
        }
        
        popupContent += '</div>';
        
        const marker = L.marker(checkpoint.coordinates, { icon: markerIcon })
            .addTo(map)
            .bindPopup(popupContent);
        
        checkpointMarkers.push({
            id: checkpoint.id,
            marker: marker,
            circle: circle,
            checkpoint: checkpoint,
            hidden: false
        });
    });
    
    console.log(`‚úÖ ${checkpointMarkers.filter(m => !m.hidden).length} checkpoints visibles ajout√©s`);
}

function checkProximityToCheckpoints() {
    if (!userPosition) return;
    
    // V√©rifier seulement les checkpoints visibles sur la carte
    checkpointMarkers.forEach(markerData => {
        if (markerData.hidden || !markerData.marker) return;
        if (foundCheckpoints.includes(markerData.checkpoint.id)) return;
        
        const checkpoint = markerData.checkpoint;
        const distance = calculateDistance(
            userPosition.lat,
            userPosition.lng,
            checkpoint.coordinates[0],
            checkpoint.coordinates[1]
        );
        
        if (distance <= GAME_CONFIG.proximityThreshold) {
            console.log(`üéØ Checkpoint ${checkpoint.name} trouv√© ! Distance: ${distance.toFixed(1)}m`);
            foundCheckpoint(checkpoint);
        }
    });
}

function foundCheckpoint(checkpoint) {
    if (foundCheckpoints.includes(checkpoint.id)) return;
    
    foundCheckpoints.push(checkpoint.id);
    
    // Supprimer la route actuelle puisque le point est atteint
    if (currentRoute) {
        map.removeLayer(currentRoute);
        currentRoute = null;
    }
    
    // Mettre √† jour le marqueur et le cercle
    const markerData = checkpointMarkers.find(m => m.id === checkpoint.id);
    if (markerData) {
        const newIcon = L.divIcon({
            className: 'checkpoint-marker found',
            html: checkpoint.emoji,
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        markerData.marker.setIcon(newIcon);
        
        // Contenu du popup diff√©rent pour le lobby
        let popupContent;
        if (checkpoint.isLobby) {
            popupContent = `
                <div style="text-align: center;">
                    <h3>${checkpoint.emoji} ${checkpoint.name}</h3>
                    <p>‚úÖ Visit√© !</p>
                    <p><em>${checkpoint.hint}</em></p>
                    <p><small>Zone de d√©clenchement: ${GAME_CONFIG.proximityThreshold}m</small></p>
                    <br>
                    <button onclick="calculateRouteFromPopup(0)" 
                            style="background: linear-gradient(135deg, ${getTeamColor()} 0%, ${getTeamColor()} 100%); 
                                   color: white; border: none; padding: 0.5rem 1rem; 
                                   border-radius: 20px; font-size: 0.9rem; cursor: pointer; 
                                   margin-top: 0.5rem;">
                        üß≠ GPS vers Lobby
                    </button>
                </div>
            `;
        } else {
            popupContent = `
                <div style="text-align: center;">
                    <h3>${checkpoint.emoji} ${checkpoint.name}</h3>
                    <p>‚úÖ D√©couvert !</p>
                    <p><small>Zone de d√©clenchement: ${GAME_CONFIG.proximityThreshold}m</small></p>
                    <br>
                    <button onclick="calculateRouteFromPopup(${checkpoint.id})" 
                            style="background: linear-gradient(135deg, ${getTeamColor()} 0%, ${getTeamColor()} 100%); 
                                   color: white; border: none; padding: 0.5rem 1rem; 
                                   border-radius: 20px; font-size: 0.9rem; cursor: pointer; 
                                   margin-top: 0.5rem;">
                        üß≠ Calculer l'itin√©raire GPS
                    </button>
                </div>
            `;
        }
        
        markerData.marker.setPopupContent(popupContent);
        
        // Mettre √† jour le cercle en vert
        markerData.circle.setStyle({
            color: '#27ae60',
            fillColor: '#27ae60'
        });
    }
    
    // Afficher l'indice (sauf pour le lobby et sauf si c'est la fin du jeu)
    if (!checkpoint.isLobby) {
        // V√©rifier si c'est le dernier checkpoint
        const teamRoute = currentTeam?.route || [];
        const nonLobbyRoute = teamRoute.filter(id => id !== 0);
        const nonLobbyFound = foundCheckpoints.filter(id => id !== 0);
        const isGameComplete = nonLobbyFound.length >= nonLobbyRoute.length && nonLobbyRoute.length > 0;
        
        if (!isGameComplete) {
            showClue(checkpoint.clue);
        } else {
            console.log('üèÅ Dernier checkpoint - pas d\'indice, seulement modal de victoire');
        }
    } else {
        // Pour le lobby, d√©bloquer le premier checkpoint selon l'√©quipe
        setTimeout(() => {
            console.log('üè† Lobby trouv√©, recherche du premier checkpoint...');
            console.log('üë• currentTeam:', currentTeam);
            console.log('üõ§Ô∏è teamRoute:', currentTeam?.route);
            
            const firstCheckpointId = getNextCheckpointForTeam();
            console.log('üéØ Premier checkpoint ID:', firstCheckpointId);
            
            if (firstCheckpointId) {
                console.log('üîì D√©bloquage du checkpoint:', firstCheckpointId);
                unlockCheckpoint(firstCheckpointId);
            } else {
                console.log('‚ùå Aucun checkpoint √† d√©bloquer trouv√©');
            }
        }, 1000);
    }
    
    // Sauvegarder la progression dans Firebase (√©quipe seulement)
    if (firebaseService && currentTeam && currentTeamId) {
        // Plus besoin d'utilisateurs - √©quipe directement
        
        // Mettre √† jour l'√©quipe aussi pour que l'admin voit les changements
        firebaseService.updateTeamProgress(currentTeamId, {
            foundCheckpoints: foundCheckpoints,
            unlockedCheckpoints: unlockedCheckpoints
        });
        
        console.log('üíæ Progression sauvegard√©e (utilisateur + √©quipe):', {
            teamId: currentTeamId,
            teamId: currentTeamId,
            foundCheckpoints, 
            unlockedCheckpoints
        });
    }
    
    // Mettre √† jour l'interface
    updateUI();
    
    // V√©rifier si l'√©quipe a termin√© son parcours (exclure le lobby du compte)
    const teamRoute = currentTeam?.route || [];
    const nonLobbyRoute = teamRoute.filter(id => id !== 0); // Exclure le lobby
    const nonLobbyFound = foundCheckpoints.filter(id => id !== 0); // Exclure le lobby
    
    console.log('üèÅ V√©rification fin de jeu:', {
        teamRoute: teamRoute,
        nonLobbyRoute: nonLobbyRoute,
        nonLobbyFound: nonLobbyFound,
        isComplete: nonLobbyFound.length >= nonLobbyRoute.length
    });
    
    const isGameComplete = nonLobbyFound.length >= nonLobbyRoute.length && nonLobbyRoute.length > 0;
    
    if (isGameComplete) {
        console.log(`üéâ √âquipe ${currentTeam?.name} a termin√© son parcours !`);
        // Pour le dernier checkpoint, afficher seulement le modal de victoire
        setTimeout(() => {
            showSuccessModal();
        }, 1000);
    } else {
        // Notification normale seulement si ce n'est pas la fin
        const message = checkpoint.isLobby ? `üè† Bienvenue au ${checkpoint.name} !` : `üéâ ${checkpoint.name} d√©couvert !`;
        showNotification(message);
    }
}

function showClue(clue) {
    // Si l'indice contient une √©nigme, afficher la modal d'√©nigme
    if (clue.riddle) {
        showRiddle(clue);
        return;
    }
    
    // Sinon, afficher la modal d'indice normale
    const modal = document.getElementById('clue-modal');
    const title = document.getElementById('clue-title');
    const text = document.getElementById('clue-text');
    const image = document.getElementById('clue-image');
    
    title.textContent = clue.title;
    text.textContent = clue.text;
    
    if (clue.image) {
        image.innerHTML = `<img src="${clue.image}" alt="${clue.title}">`;
    } else {
        image.innerHTML = '';
    }
    
    modal.style.display = 'block';
}

function showRiddle(clue) {
    const modal = document.getElementById('riddle-modal');
    const question = document.getElementById('riddle-question');
    const answerInput = document.getElementById('riddle-answer');
    const hintElement = document.getElementById('riddle-hint');
    const feedback = document.getElementById('riddle-feedback');
    
    question.textContent = clue.riddle.question;
    hintElement.textContent = clue.riddle.hint;
    hintElement.style.display = 'none';
    answerInput.value = '';
    feedback.innerHTML = '';
    feedback.className = '';
    
    modal.style.display = 'block';
    answerInput.focus();
}

function checkRiddleAnswer() {
    const answerInput = document.getElementById('riddle-answer');
    const hintElement = document.getElementById('riddle-hint');
    const feedback = document.getElementById('riddle-feedback');
    const userAnswer = answerInput.value.trim().toLowerCase();
    
    // R√©cup√©rer l'√©nigme du checkpoint actuel depuis la modal
    const riddleQuestion = document.getElementById('riddle-question').textContent;
    
    // Trouver le checkpoint correspondant √† cette √©nigme
    const currentCheckpoint = GAME_CONFIG.checkpoints.find(cp => 
        cp.clue && cp.clue.riddle && cp.clue.riddle.question === riddleQuestion
    );
    
    if (!currentCheckpoint || !currentCheckpoint.clue || !currentCheckpoint.clue.riddle) {
        console.error('‚ùå Impossible de trouver l\'√©nigme actuelle');
        feedback.innerHTML = '‚ùå Erreur syst√®me. Veuillez recharger la page.';
        feedback.className = 'error';
        return;
    }
    
    const correctAnswer = currentCheckpoint.clue.riddle.answer.toLowerCase();
    
    if (userAnswer === correctAnswer) {
        // Bonne r√©ponse !
        const successMessage = currentCheckpoint.clue.text || 'üéâ Correct ! √ânigme r√©solue !';
        feedback.innerHTML = successMessage;
        feedback.className = 'success';
        
        // D√©bloquer le prochain point selon l'√©quipe
        const nextCheckpointId = getNextCheckpointForTeam();
        if (nextCheckpointId) {
            unlockCheckpoint(nextCheckpointId);
            
            // Message personnalis√© selon le prochain checkpoint
            const nextCheckpoint = GAME_CONFIG.checkpoints.find(cp => cp.id === nextCheckpointId);
            const nextName = nextCheckpoint ? nextCheckpoint.name : 'prochain point';
            feedback.innerHTML = `üéâ Correct ! "${nextName}" est maintenant d√©bloqu√© !`;
        } else {
            feedback.innerHTML = 'üéâ Correct ! Vous avez termin√© votre parcours !';
        }
        
        setTimeout(() => {
            document.getElementById('riddle-modal').style.display = 'none';
            
            // Zoomer sur le nouveau point d√©bloqu√©
            if (nextCheckpointId) {
                const unlockedCheckpoint = GAME_CONFIG.checkpoints.find(cp => cp.id === nextCheckpointId);
                if (unlockedCheckpoint) {
                    console.log('üéØ Zoom vers le checkpoint d√©bloqu√©:', unlockedCheckpoint.name);
                    centerMapOnCheckpoint(unlockedCheckpoint);
                    showNotification(`üéØ "${unlockedCheckpoint.name}" d√©bloqu√© ! Suivez la carte.`);
                } else {
                    console.warn('‚ö†Ô∏è Checkpoint d√©bloqu√© non trouv√©:', nextCheckpointId);
                    showNotification('üéØ Prochain d√©fi d√©bloqu√© ! Navigation GPS activ√©e.');
                }
            } else {
                showNotification('üèÜ Parcours termin√© ! F√©licitations !');
            }
        }, 2000);
        
    } else {
        // Mauvaise r√©ponse
        feedback.innerHTML = '‚ùå R√©ponse incorrecte. Essayez encore !';
        feedback.className = 'error';
        hintElement.style.display = 'block';
        answerInput.value = '';
        answerInput.focus();
    }
}

function unlockCheckpoint(checkpointId) {
    if (unlockedCheckpoints.includes(checkpointId)) return;
    
    unlockedCheckpoints.push(checkpointId);
    
    // Trouver le checkpoint dans la liste
    const markerData = checkpointMarkers.find(m => m.id === checkpointId);
    if (markerData && markerData.hidden) {
        const checkpoint = markerData.checkpoint;
        
        // R√âV√âLER le point sur la carte (il √©tait cach√©)
        console.log(`üé≠ R√©v√©lation du checkpoint ${checkpoint.name} sur la carte`);
        
        // Cr√©er le cercle de proximit√©
        const circle = L.circle(checkpoint.coordinates, {
            color: '#3498db',
            fillColor: '#3498db',
            fillOpacity: 0.1,
            radius: GAME_CONFIG.proximityThreshold,
            weight: 2,
            opacity: 0.6
        }).addTo(map);
        
        // Cr√©er le marqueur
        const markerIcon = L.divIcon({
            className: 'checkpoint-marker',
            html: checkpoint.emoji,
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        
        // Cr√©er le contenu du popup avec bouton GPS
        let popupContent = `
            <div style="text-align: center;">
                <h3>${checkpoint.emoji} ${checkpoint.name}</h3>
                <p>üîç √Ä d√©couvrir</p>
                <p><em>${checkpoint.hint}</em></p>
                <p><small>Zone de d√©clenchement: ${GAME_CONFIG.proximityThreshold}m</small></p>
        `;
        
        // Ajouter le bouton GPS
        if (userPosition) {
            popupContent += `
                <br>
                <button onclick="calculateRouteFromPopup(${checkpoint.id})" 
                        style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); 
                               color: white; border: none; padding: 0.5rem 1rem; 
                               border-radius: 20px; font-size: 0.9rem; cursor: pointer; 
                               margin-top: 0.5rem;">
                    üß≠ Calculer l'itin√©raire GPS
                </button>
            `;
        }
        
        popupContent += '</div>';
        
        const marker = L.marker(checkpoint.coordinates, { icon: markerIcon })
            .addTo(map)
            .bindPopup(popupContent);
        
        // Mettre √† jour les donn√©es du marqueur
        markerData.marker = marker;
        markerData.circle = circle;
        markerData.hidden = false;
        
        // Centrer la carte sur le nouveau point d√©bloqu√©
        centerMapOnCheckpoint(checkpoint);
    }
    
    // Sauvegarder la progression dans Firebase (√©quipe seulement)
    if (firebaseService && currentTeam && currentTeamId) {
        // Plus besoin d'utilisateurs - √©quipe directement
        
        // Mettre √† jour l'√©quipe aussi pour que l'admin voit les changements
        firebaseService.updateTeamProgress(currentTeamId, {
            foundCheckpoints: foundCheckpoints,
            unlockedCheckpoints: unlockedCheckpoints
        });
        
        console.log('üíæ Progression sauvegard√©e (utilisateur + √©quipe):', {
            teamId: currentTeamId,
            teamId: currentTeamId,
            foundCheckpoints, 
            unlockedCheckpoints
        });
    }
    
    updateHint();
    console.log(`üîì Checkpoint ${checkpointId} d√©bloqu√© et r√©v√©l√© !`);
    
    // Forcer une notification pour v√©rifier la synchronisation
    setTimeout(() => {
        console.log('üîç V√©rification synchronisation apr√®s d√©bloquage:', {
            checkpointId,
            foundCheckpoints,
            unlockedCheckpoints,
            currentTeam: currentTeam?.name,
            currentTeamId
        });
    }, 1000);
}

function centerMapOnCheckpoint(checkpoint) {
    console.log(`üéØ Centrage de la carte sur ${checkpoint.name}`);
    
    // Animation fluide vers le nouveau point
    map.flyTo(checkpoint.coordinates, GAME_CONFIG.zoom, {
        animate: true,
        duration: 2 // 2 secondes d'animation
    });
    
    // Ouvrir le popup automatiquement apr√®s l'animation pour montrer le bouton GPS
    setTimeout(() => {
        const markerData = checkpointMarkers.find(m => m.id === checkpoint.id);
        if (markerData) {
            markerData.marker.openPopup();
        }
    }, 2500); // Ouvrir le popup apr√®s l'animation
}

async function calculateRoute(from, toCheckpoint) {
    console.log(`üó∫Ô∏è Calcul de l'itin√©raire vers ${toCheckpoint.name}`);
    
    // Stocker la destination pour le recalcul automatique
    currentDestination = toCheckpoint;
    
    // Afficher une notification de chargement
    showNotification('‚è≥ Calcul de l\'itin√©raire en cours...');
    
    try {
        // Supprimer l'ancienne route
        if (currentRoute) {
            map.removeLayer(currentRoute);
            currentRoute = null;
        }
        
        // Coordonn√©es au format [longitude, latitude] pour ORS
        const start = [from.lng, from.lat];
        const end = [toCheckpoint.coordinates[1], toCheckpoint.coordinates[0]];
        
        console.log('üìç Coordonn√©es:', { start, end });
        
        // Appel √† l'API OpenRouteService
        const response = await fetch('https://api.openrouteservice.org/v2/directions/foot-walking', {
            method: 'POST',
            headers: {
                'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',
                'Authorization': GAME_CONFIG.orsApiKey,
                'Content-Type': 'application/json; charset=utf-8'
            },
            body: JSON.stringify({
                coordinates: [start, end],
                format: 'geojson',
                instructions: true,
                language: 'fr'
            })
        });
        
        console.log('üì° R√©ponse ORS:', response.status);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå Erreur ORS:', errorText);
            throw new Error(`Erreur ORS: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        console.log('üìä Donn√©es re√ßues:', data);
        
        if (data.routes && data.routes.length > 0) {
            const route = data.routes[0];
            console.log('üõ£Ô∏è Route data:', route);
            
            // V√©rifier si on a une g√©om√©trie valide
            if (route.geometry) {
                let routeGeoJSON;
                
                // Si c'est une cha√Æne encod√©e (polyline), on la d√©code
                if (typeof route.geometry === 'string') {
                    console.log('üîÑ D√©codage de la polyline:', route.geometry);
                    const coordinates = decodePolyline(route.geometry);
                    console.log('üìç Coordonn√©es d√©cod√©es:', coordinates);
                    routeGeoJSON = {
                        type: "Feature",
                        geometry: {
                            type: "LineString",
                            coordinates: coordinates
                        },
                        properties: route
                    };
                } else if (route.geometry.coordinates) {
                    // Si c'est d√©j√† un GeoJSON
                    routeGeoJSON = {
                        type: "Feature",
                        geometry: {
                            type: "LineString",
                            coordinates: route.geometry.coordinates
                        },
                        properties: route
                    };
                }
                
                console.log('üìç GeoJSON cr√©√©:', routeGeoJSON);
                
                // V√©rifier que le GeoJSON a √©t√© cr√©√© correctement
                if (routeGeoJSON && routeGeoJSON.geometry && routeGeoJSON.geometry.coordinates && routeGeoJSON.geometry.coordinates.length > 0) {
                    // Afficher la route sur la carte
                    currentRoute = L.geoJSON(routeGeoJSON, {
                    style: {
                        color: getTeamColor(),
                        weight: 5,
                        opacity: 0.8,
                        dashArray: '10, 5'
                    }
                }).addTo(map);
                
                // Extraire les instructions si disponibles
                if (route.segments && route.segments[0] && route.segments[0].steps) {
                    const instructions = route.segments[0].steps;
                    displayNavigationInstructions(instructions, route.summary);
                } else {
                    // Instructions basiques si pas de segments d√©taill√©s
                    displayBasicNavigation(route.summary);
                }
                
                    console.log('‚úÖ Itin√©raire calcul√© et affich√©');
                    showNotification('üß≠ Itin√©raire GPS calcul√© !');
                } else {
                    console.error('‚ùå Impossible de cr√©er le GeoJSON:', routeGeoJSON);
                    showNotification('Erreur: Format de route invalide', 'error');
                }
            } else {
                console.error('‚ùå Pas de g√©om√©trie dans la route:', route);
                showNotification('Erreur: Pas de g√©om√©trie de route', 'error');
            }
        }
        
    } catch (error) {
        console.error('‚ùå Erreur lors du calcul de l\'itin√©raire:', error);
        showNotification('Impossible de calculer l\'itin√©raire GPS', 'error');
    }
}

function displayNavigationInstructions(steps, summary) {
    const hintText = document.getElementById('hint-text');
    
    // Informations g√©n√©rales
    const distance = (summary.distance / 1000).toFixed(2);
    const duration = Math.round(summary.duration / 60);
    
    // Premi√®re instruction
    const firstStep = steps[1] || steps[0]; // Ignorer "D√©part"
    const instruction = firstStep ? firstStep.instruction : 'Suivez l\'itin√©raire sur la carte';
    
    hintText.innerHTML = `
        <div style="background: #e8f5e8; padding: 1rem; border-radius: 10px; border-left: 4px solid ${getTeamColor()};">
            <h4 style="margin: 0 0 0.5rem 0; color: ${getTeamColor()};">üß≠ Navigation GPS</h4>
            <p style="margin: 0 0 0.5rem 0; font-weight: bold;">${instruction}</p>
            <div style="display: flex; justify-content: space-between; font-size: 0.9rem; color: #666;">
                <span>üìç ${distance} km</span>
                <span>üö∂ ${duration} min</span>
            </div>
        </div>
    `;
}

function displayBasicNavigation(summary) {
    const hintText = document.getElementById('hint-text');
    
    // Informations g√©n√©rales
    const distance = (summary.distance / 1000).toFixed(2);
    const duration = Math.round(summary.duration / 60);
    
    hintText.innerHTML = `
        <div style="background: #e8f5e8; padding: 1rem; border-radius: 10px; border-left: 4px solid ${getTeamColor()};">
            <h4 style="margin: 0 0 0.5rem 0; color: ${getTeamColor()};">üß≠ Navigation GPS</h4>
            <p style="margin: 0 0 0.5rem 0; font-weight: bold;">Suivez l'itin√©raire trac√© sur la carte</p>
            <div style="display: flex; justify-content: space-between; font-size: 0.9rem; color: #666;">
                <span>üìç ${distance} km</span>
                <span>üö∂ ${duration} min</span>
            </div>
        </div>
    `;
}

function showSuccessModal() {
    const modal = document.getElementById('success-modal');
    const messageEl = document.getElementById('success-message');
    const teamInfoEl = document.getElementById('success-team-info');
    
    // Personnaliser le message selon l'√©quipe
    if (currentTeam && currentTeam.name) {
        messageEl.textContent = `L'√©quipe "${currentTeam.name}" a termin√© son parcours !`;
        teamInfoEl.textContent = `F√©licitations √©quipe ${currentTeam.name} ! Vous avez relev√© tous les d√©fis de votre parcours. Tous les points restent accessibles pour continuer l'exploration.`;
    } else {
        messageEl.textContent = 'Vous avez termin√© le jeu de piste !';
        teamInfoEl.textContent = 'Bravo pour cette belle aventure ! Vous pouvez continuer √† explorer.';
    }
    
    modal.style.display = 'block';
    console.log(`üèÜ Modal de succ√®s affich√© pour l'√©quipe ${currentTeam?.name}`);
    console.log('üìã Contenu du modal:', {
        message: messageEl.textContent,
        teamInfo: teamInfoEl.textContent
    });
}

function updateUI() {
    updateProgress();
    updatePlayerRouteProgress();
    updateHint();
    // updateHelpUI(); // Plus n√©cessaire - boutons int√©gr√©s dans le parcours
}

function updatePlayerRouteProgress() {
    const routeListElement = document.getElementById('player-route-list');

    if (!currentTeam || !currentTeam.route) {
        routeListElement.innerHTML = '<p style="color: #e74c3c;">‚ùå Aucun parcours d√©fini</p>';
        return;
    }
    
    // V√©rifier que les checkpoints sont charg√©s
    if (!GAME_CONFIG.checkpoints || GAME_CONFIG.checkpoints.length === 0) {
        console.warn('‚ö†Ô∏è updatePlayerRouteProgress appel√© avant le chargement des checkpoints');
        routeListElement.innerHTML = '<p style="color: #f39c12;">üîÑ Chargement des points...</p>';
        return;
    }
    
    const teamRoute = currentTeam.route;
    let progressHTML = '';
    
    teamRoute.forEach((checkpointId, index) => {
        const isFound = foundCheckpoints.includes(checkpointId);
        const isUnlocked = unlockedCheckpoints.includes(checkpointId);
        
        // Debug pour voir l'√©tat de chaque checkpoint
        console.log(`üîç Checkpoint ${checkpointId} √©tat:`, {
            isFound,
            isUnlocked,
            foundCheckpoints,
            unlockedCheckpoints
        });
        
        // Trouver les infos du checkpoint
        const checkpoint = GAME_CONFIG.checkpoints.find(cp => cp.id === checkpointId);
        const checkpointName = checkpoint ? `${checkpoint.emoji} ${checkpoint.name}` : `Point ${checkpointId}`;
        
        // Debug pour voir si le checkpoint est trouv√©
        if (!checkpoint) {
            console.warn(`‚ö†Ô∏è Checkpoint ${checkpointId} non trouv√© dans GAME_CONFIG.checkpoints:`, 
                GAME_CONFIG.checkpoints.map(cp => cp.id));
        }
        
        // D√©terminer le statut et la couleur
        let statusIcon, statusText, statusColor, clickable = false;
        
        if (isFound) {
            statusIcon = '‚úÖ';
            statusText = 'trouv√©';
            statusColor = '#27ae60';
        } else if (isUnlocked) {
            statusIcon = 'üéØ';
            statusText = 'accessible';
            statusColor = '#f39c12';
            clickable = true; // Peut cliquer pour zoomer
        } else {
            statusIcon = 'üîí';
            statusText = 'verrouill√©';
            statusColor = '#95a5a6';
        }
        
        const clickHandler = clickable && userPosition ? `onclick="zoomToCheckpoint(${checkpointId})"` : '';
        const cursorStyle = clickable && userPosition ? 'cursor: pointer;' : '';
        
        // D√©terminer les boutons d'aide selon le statut
        let helpButtons = '';
        if (!isFound && !isUnlocked) {
            // Checkpoint verrouill√© ‚Üí bouton demander localisation
            helpButtons = `<button class="help-btn-small" onclick="requestLocationHelpFor(${checkpointId})" title="Demander la localisation">üìç</button>`;
        } else if (isUnlocked && !isFound) {
            // Checkpoint d√©bloqu√© mais pas trouv√© ‚Üí v√©rifier le type et s'il a une √©nigme
            console.log(`üîç Debug checkpoint ${checkpointId}:`, {
                checkpoint,
                type: checkpoint?.type,
                hasClue: !!checkpoint?.clue,
                hasRiddle: !!checkpoint?.clue?.riddle,
                riddleData: checkpoint?.clue?.riddle
            });
            
            if (checkpoint?.type === 'final') {
                // Point d'arriv√©e ‚Üí toujours bouton localisation (pas d'√©preuve)
                helpButtons = `<button class="help-btn-small" onclick="requestLocationHelpFor(${checkpointId})" title="Demander l'aide pour trouver le point d'arriv√©e">üèÅ</button>`;
            } else if (checkpoint?.clue?.riddle) {
                // Avec √©nigme ‚Üí bouton aide √©nigme
                helpButtons = `<button class="help-btn-small" onclick="requestRiddleHelpFor(${checkpointId})" title="Demander l'aide pour l'√©nigme">üß©</button>`;
            } else {
                // Sans √©nigme ‚Üí bouton aide g√©n√©rale (localisation physique)
                helpButtons = `<button class="help-btn-small" onclick="requestLocationHelpFor(${checkpointId})" title="Demander de l'aide pour trouver ce point">üìç</button>`;
            }
        }
        
        progressHTML += `
            <div class="player-checkpoint-item" 
                 style="color: ${statusColor}; ${cursorStyle}" 
                 ${clickHandler}>
                <div class="checkpoint-info">
                    ${statusIcon} ${index + 1}. ${checkpointName} 
                    <small>(${statusText})</small>
                    ${clickable && userPosition ? ' üß≠' : ''}
                </div>
                <div class="checkpoint-actions">
                    ${helpButtons}
                </div>
            </div>
        `;
    });
    
    routeListElement.innerHTML = progressHTML;
}

// Fonction pour zoomer sur un checkpoint sp√©cifique
function zoomToCheckpoint(checkpointId) {
    const checkpoint = GAME_CONFIG.checkpoints.find(cp => cp.id === checkpointId);
    if (checkpoint && userPosition) {
        // Fermer tous les popups ouverts
        map.closePopup();
        
        // Centrer la carte sur le checkpoint
        map.flyTo(checkpoint.coordinates, GAME_CONFIG.zoom, {
            animate: true,
            duration: 1.5
        });
        
        // Ouvrir le popup du checkpoint apr√®s l'animation
        setTimeout(() => {
            const markerData = checkpointMarkers.find(m => m.id === checkpointId);
            if (markerData && markerData.marker) {
                markerData.marker.openPopup();
            }
        }, 2000);
        
        showNotification(`üéØ Zoom vers ${checkpoint.name}`, 'info');
    }
}

// Exposer la fonction globalement
window.zoomToCheckpoint = zoomToCheckpoint;

function updateProgress() {
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    
    // Exclure le lobby du d√©compte de progression
    const nonLobbyCheckpoints = GAME_CONFIG.checkpoints.filter(cp => !cp.isLobby);
    const nonLobbyFound = foundCheckpoints.filter(id => {
        const cp = GAME_CONFIG.checkpoints.find(c => c.id === id);
        return cp && !cp.isLobby;
    });
    
    const percentage = (nonLobbyFound.length / nonLobbyCheckpoints.length) * 100;
    
    progressFill.style.width = `${percentage}%`;
    progressText.textContent = `${nonLobbyFound.length} / ${nonLobbyCheckpoints.length} d√©fis r√©solus`;
}

function updateHint() {
    const hintText = document.getElementById('hint-text');
    const gpsBtn = document.getElementById('gps-route-btn');
    
    if (!userPosition) {
        hintText.textContent = 'Trouvez votre position pour commencer l\'aventure !';
        gpsBtn.style.display = 'none';
        return;
    }
    
    // V√©rifier si l'√©quipe a termin√© SON parcours (pas tous les checkpoints du jeu)
    const teamRoute = currentTeam?.route || [];
    const nonLobbyRoute = teamRoute.filter(id => id !== 0); // Exclure le lobby
    const nonLobbyFound = foundCheckpoints.filter(id => id !== 0); // Exclure le lobby
    const isTeamGameComplete = nonLobbyRoute.length > 0 && nonLobbyFound.length >= nonLobbyRoute.length;
    
    if (isTeamGameComplete) {
        hintText.textContent = `üéâ F√©licitations ! √âquipe ${currentTeam?.name || 'votre √©quipe'} a termin√© son parcours !`;
        gpsBtn.style.display = 'none';
        console.log('üèÜ Affichage message fin de jeu:', {
            √©quipe: currentTeam?.name,
            route: nonLobbyRoute,
            trouv√©s: nonLobbyFound,
            message: 'Parcours √©quipe termin√©'
        });
        return;
    }
    
    // Trouver le prochain checkpoint dans la route de l'√©quipe (d√©bloqu√© mais pas trouv√©)
    // R√©utiliser la variable teamRoute d√©j√† d√©clar√©e
    let nextCheckpoint = null;
    
    for (const checkpointId of teamRoute) {
        if (checkpointId === 0) continue; // Ignorer le lobby
        
        const isFound = foundCheckpoints.includes(checkpointId);
        const isUnlocked = unlockedCheckpoints.includes(checkpointId);
        
        if (isUnlocked && !isFound) {
            nextCheckpoint = GAME_CONFIG.checkpoints.find(cp => cp.id === checkpointId);
            break;
        }
    }
    
    console.log('üéØ Prochain checkpoint pour hint:', {
        teamRoute,
        foundCheckpoints,
        unlockedCheckpoints,
        nextCheckpoint: nextCheckpoint?.name || 'Aucun'
    });
    
    if (nextCheckpoint) {
        const distance = calculateDistance(
            userPosition.lat,
            userPosition.lng,
            nextCheckpoint.coordinates[0],
            nextCheckpoint.coordinates[1]
        );
        
        hintText.innerHTML = `
            <strong>${nextCheckpoint.hint}</strong><br>
            <small>Distance approximative: ${distance > 1000 ? 
                (distance/1000).toFixed(1) + ' km' : 
                Math.round(distance) + ' m'}</small><br>
            <small style="color: #666;">üí° Cliquez sur le marqueur ${nextCheckpoint.emoji} pour obtenir l'itin√©raire GPS</small>
        `;
        
    } else {
        // Tous les checkpoints d√©bloqu√©s sont trouv√©s, mais il y en a peut-√™tre des verrouill√©s
        const lockedCheckpoint = GAME_CONFIG.checkpoints.find(cp => 
            cp.locked && !unlockedCheckpoints.includes(cp.id)
        );
        
        if (lockedCheckpoint) {
            hintText.innerHTML = `<strong>${lockedCheckpoint.hint}</strong>`;
        }
    }
    
    // Cacher le bouton GPS du panneau principal
    gpsBtn.style.display = 'none';
}

function updateStatus(message) {
    document.getElementById('status').textContent = message;
}

function updateCoordinatesDisplay() {
    const coordsElement = document.getElementById('coordinates');
    
    if (userPosition) {
        coordsElement.textContent = `${userPosition.lat.toFixed(6)}, ${userPosition.lng.toFixed(6)}`;
    } else {
        coordsElement.textContent = 'En attente de g√©olocalisation...';
    }
}

function setupEventListeners() {
    // Fermer les modales
    document.querySelector('#clue-modal .close').addEventListener('click', () => {
        document.getElementById('clue-modal').style.display = 'none';
    });
    
    document.getElementById('clue-close-btn').addEventListener('click', () => {
        document.getElementById('clue-modal').style.display = 'none';
    });
    
    document.getElementById('close-success-btn').addEventListener('click', () => {
        document.getElementById('success-modal').style.display = 'none';
        console.log('üéÆ Modal de succ√®s ferm√© - exploration continue');
    });
    
    
    // √âv√©nements pour la modal d'√©nigme
    document.getElementById('riddle-submit').addEventListener('click', () => {
        checkRiddleAnswer();
    });
    
    document.getElementById('riddle-answer').addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            checkRiddleAnswer();
        }
    });
    
    // Anciens boutons d'aide supprim√©s - maintenant int√©gr√©s dans le parcours
    
    // Fermer les modales en cliquant √† l'ext√©rieur
    window.addEventListener('click', (event) => {
        const clueModal = document.getElementById('clue-modal');
        const riddleModal = document.getElementById('riddle-modal');
        const successModal = document.getElementById('success-modal');
        
        if (event.target === clueModal) {
            clueModal.style.display = 'none';
        }
        if (event.target === riddleModal) {
            riddleModal.style.display = 'none';
        }
        if (event.target === successModal) {
            successModal.style.display = 'none';
        }
    });
}

// FONCTION OBSOL√àTE - Plus utilis√©e depuis la modification du syst√®me de victoire
// Les √©quipes gardent maintenant tous leurs points apr√®s la victoire
function restartGame() {
    console.log(`üîÑ Restart demand√© pour l'√©quipe ${currentTeam?.name} - FONCTION OBSOL√àTE`);
    
    // Reset local
    foundCheckpoints = [];
    unlockedCheckpoints = [0]; // Remettre au lobby
    document.getElementById('success-modal').style.display = 'none';
    
    // Sauvegarder le reset dans Firebase
    if (firebaseService && currentTeam && currentTeamId) {
        firebaseService.updateTeamProgress(currentTeamId, {
            foundCheckpoints: foundCheckpoints,
            unlockedCheckpoints: unlockedCheckpoints
        });
        console.log('üíæ Reset sauvegard√© dans Firebase');
    }
    
    // Remettre √† jour tous les marqueurs et cercles
    checkpointMarkers.forEach(markerData => {
        const checkpoint = markerData.checkpoint;
        const isUnlocked = unlockedCheckpoints.includes(checkpoint.id);
        const isLocked = checkpoint.locked && !isUnlocked;
        
        let markerClass = 'checkpoint-marker';
        if (isLocked) markerClass += ' locked';
        
        const newIcon = L.divIcon({
            className: markerClass,
            html: isLocked ? 'üîí' : checkpoint.emoji,
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        markerData.marker.setIcon(newIcon);
        markerData.marker.setPopupContent(`
            <div style="text-align: center;">
                <h3>${isLocked ? 'üîí' : checkpoint.emoji} ${checkpoint.name}</h3>
                <p>${isLocked ? 'üîí Verrouill√©' : 'üîç √Ä d√©couvrir'}</p>
                <p><em>${checkpoint.hint}</em></p>
                <p><small>Zone de d√©clenchement: ${GAME_CONFIG.proximityThreshold}m</small></p>
            </div>
        `);
        
        // Remettre √† jour le cercle
        markerData.circle.setStyle({
            color: isLocked ? '#95a5a6' : '#3498db',
            fillColor: isLocked ? '#95a5a6' : '#3498db'
        });
    });
    
    updateUI();
    showNotification('Jeu red√©marr√© ! Bonne chance !');
}

function showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.remove();
    }, 3000);
}

// Fonction utilitaire pour calculer la distance entre deux points
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371e3; // Rayon de la Terre en m√®tres
    const œÜ1 = lat1 * Math.PI/180;
    const œÜ2 = lat2 * Math.PI/180;
    const ŒîœÜ = (lat2-lat1) * Math.PI/180;
    const ŒîŒª = (lng2-lng1) * Math.PI/180;

    const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) *
              Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c; // Distance en m√®tres
}

// Debug: Fonction pour simuler une position (utile pour les tests)
function simulatePosition(lat, lng) {
    console.log(`üß™ Simulation de position: ${lat}, ${lng}`);
    
    userPosition = { lat, lng, accuracy: 10 };
    updateUserMarker();
    updateCoordinatesDisplay();
    checkProximityToCheckpoints();
    updateHint();
    updateStatus('Position simul√©e');
}

// Fonction appel√©e depuis le popup du marqueur
function calculateRouteFromPopup(checkpointId) {
    const checkpoint = GAME_CONFIG.checkpoints.find(cp => cp.id === checkpointId);
    if (checkpoint && userPosition) {
        // Fermer tous les popups ouverts
        map.closePopup();
        
        calculateRoute(userPosition, checkpoint);
    }
}

// Exposer les fonctions pour les tests et les popups
window.simulatePosition = simulatePosition;
window.calculateRouteFromPopup = calculateRouteFromPopup;
window.requestLocationHelpFor = requestLocationHelpFor;
window.requestRiddleHelpFor = requestRiddleHelpFor;

// Fonction supprim√©e - les checkpoints sont maintenant cr√©√©s via l'admin

// D√©marrer la synchronisation temps r√©el avec l'√©quipe
function startTeamSync() {
    if (!firebaseService || !currentTeamId) {
        console.warn('‚ö†Ô∏è Impossible de d√©marrer la synchronisation √©quipe:', {firebaseService: !!firebaseService, currentTeamId});
        return;
    }
    
    console.log('üîÑ D√©marrage synchronisation temps r√©el √©quipe:', currentTeamId);
    
    firebaseService.onTeamChange(currentTeamId, (teamData) => {
        console.log('üì° Mise √† jour re√ßue de l\'√©quipe:', teamData);
        
        if (!teamData) {
            console.warn('‚ö†Ô∏è Donn√©es d\'√©quipe vides re√ßues');
            return;
        }
        
        // Mettre √† jour les donn√©es de l'√©quipe
        currentTeam = teamData;
        
        // V√©rifier si les checkpoints d√©bloqu√©s ont chang√© (action admin)
        const newUnlockedCheckpoints = teamData.unlockedCheckpoints || [0];
        const currentUnlocked = unlockedCheckpoints || [0];
        
        const hasNewUnlocked = newUnlockedCheckpoints.some(id => !currentUnlocked.includes(id));
        
        if (hasNewUnlocked) {
            console.log('üîì Nouveaux checkpoints d√©bloqu√©s par admin:', {
                avant: currentUnlocked,
                apr√®s: newUnlockedCheckpoints,
                nouveaux: newUnlockedCheckpoints.filter(id => !currentUnlocked.includes(id))
            });
            
            // Mettre √† jour les checkpoints d√©bloqu√©s
            unlockedCheckpoints = [...newUnlockedCheckpoints];
            
            // R√©v√©ler les nouveaux checkpoints sur la carte
            const newlyUnlocked = newUnlockedCheckpoints.filter(id => !currentUnlocked.includes(id));
            newlyUnlocked.forEach(checkpointId => {
                if (checkpointId !== 0) { // Ignorer le lobby
                    revealCheckpointOnMap(checkpointId);
                }
            });
            
            // Mettre √† jour l'interface
            updateUI();
            
            // Notification √† l'utilisateur
            if (newlyUnlocked.length > 0) {
                const checkpointNames = newlyUnlocked.map(id => {
                    const cp = GAME_CONFIG.checkpoints.find(c => c.id === id);
                    return cp ? cp.name : `Point ${id}`;
                }).join(', ');
                
                showNotification(`üéØ Admin a d√©bloqu√© : ${checkpointNames}`, 'success');
            }
        }
        
        // 1 √âQUIPE = 1 JOUEUR : Synchroniser foundCheckpoints avec Firebase
        const firebaseFoundCheckpoints = teamData.foundCheckpoints || [];
        const localFoundCheckpoints = foundCheckpoints || [];
        
        // Si Firebase a plus de checkpoints trouv√©s, on synchronise
        if (firebaseFoundCheckpoints.length > localFoundCheckpoints.length) {
            console.log('üîÑ Synchronisation foundCheckpoints depuis Firebase:', {
                local: localFoundCheckpoints,
                firebase: firebaseFoundCheckpoints,
                nouveaux: firebaseFoundCheckpoints.filter(id => !localFoundCheckpoints.includes(id))
            });
            foundCheckpoints = [...firebaseFoundCheckpoints];
            
            // Mettre √† jour l'affichage apr√®s synchronisation
            updatePlayerRouteProgress();
            updateProgress();
        } else {
            console.log('üì± foundCheckpoints locaux √† jour:', {
                local: localFoundCheckpoints,
                firebase: firebaseFoundCheckpoints
            });
        }
        
        // Mettre √† jour les infos d'√©quipe
        showTeamInfo();
        updateProgress();
        
        // Plus besoin de v√©rifier les demandes d'aide - int√©gr√©es dans le parcours
    });
}

// R√©v√©ler un checkpoint sur la carte (appel√© quand l'admin d√©bloque)
function revealCheckpointOnMap(checkpointId) {
    const markerData = checkpointMarkers.find(m => m.id === checkpointId);
    
    if (markerData && markerData.hidden) {
        const checkpoint = markerData.checkpoint;
        
        console.log(`üé≠ R√©v√©lation du checkpoint ${checkpoint.name} (d√©bloqu√© par admin)`);
        
        // Cr√©er le cercle de proximit√©
        const circle = L.circle(checkpoint.coordinates, {
            color: '#f39c12', // Orange pour indiquer d√©bloqu√© par admin
            fillColor: '#f39c12',
            fillOpacity: 0.1,
            radius: GAME_CONFIG.proximityThreshold,
            weight: 2,
            opacity: 0.6
        }).addTo(map);
        
        // Cr√©er le marqueur
        const markerIcon = L.divIcon({
            className: 'checkpoint-marker admin-unlocked',
            html: checkpoint.emoji,
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        
        // Cr√©er le contenu du popup
        let popupContent = `
            <div style="text-align: center;">
                <h3>${checkpoint.emoji} ${checkpoint.name}</h3>
                <p>üîì D√©bloqu√© par l'admin</p>
                <p><em>${checkpoint.hint}</em></p>
                <p><small>Zone de d√©clenchement: ${GAME_CONFIG.proximityThreshold}m</small></p>
        `;
        
        // Ajouter le bouton GPS
        if (userPosition) {
            popupContent += `
                <br>
                <button onclick="calculateRouteFromPopup(${checkpoint.id})" 
                        style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); 
                               color: white; border: none; padding: 0.5rem 1rem; 
                               border-radius: 20px; font-size: 0.9rem; cursor: pointer; 
                               margin-top: 0.5rem;">
                    üß≠ Calculer l'itin√©raire GPS
                </button>
            `;
        }
        
        popupContent += '</div>';
        
        const marker = L.marker(checkpoint.coordinates, { icon: markerIcon })
            .addTo(map)
            .bindPopup(popupContent);
        
        // Mettre √† jour les donn√©es du marqueur
        markerData.marker = marker;
        markerData.circle = circle;
        markerData.hidden = false;
        
        // Animation de zoom vers le nouveau checkpoint
        setTimeout(() => {
            centerMapOnCheckpoint(checkpoint);
        }, 500);
    }
}

// Synchronisation temps r√©el des checkpoints
function syncCheckpoints() {
    if (!firebaseService) {
        console.warn('‚ö†Ô∏è Firebase Service non disponible pour la synchronisation des checkpoints');
        return;
    }
    
    console.log('üîÑ Synchronisation des checkpoints...');
    
    firebaseService.getCheckpoints().then((checkpoints) => {
        console.log('üîÑ Checkpoints synchronis√©s:', checkpoints);
        
        if (!checkpoints || checkpoints.length === 0) {
            console.warn('‚ö†Ô∏è Aucun checkpoint trouv√© dans Firebase');
            showNotification('‚ö†Ô∏è Aucun checkpoint configur√©. Contactez l\'administrateur.', 'error');
            return;
        }
        
        // V√©rifier qu'il y a au moins un lobby
        const hasLobby = checkpoints.some(cp => cp.isLobby || cp.type === 'lobby');
        if (!hasLobby) {
            console.warn('‚ö†Ô∏è Aucun lobby trouv√© dans les checkpoints');
            showNotification('‚ö†Ô∏è Configuration incompl√®te. Contactez l\'administrateur.', 'error');
        }
        
        GAME_CONFIG.checkpoints = checkpoints;
        
        // Ajouter les checkpoints √† la carte seulement si on a une carte initialis√©e
        if (isMapInitialized) {
            addCheckpointsToMap();
        }
        
        // Mettre √† jour l'affichage du parcours maintenant que les checkpoints sont charg√©s
        updatePlayerRouteProgress();
        updateUI();
    }).catch((error) => {
        console.error('‚ùå Erreur lors de la synchronisation des checkpoints:', error);
        showNotification('‚ùå Erreur de chargement des points. Rechargez la page.', 'error');
    });
}

// ===== SYST√àME D'AIDE =====

// Variables pour le syst√®me d'aide
let currentHelpRequests = [];

// Appeler la synchronisation apr√®s l'initialisation
// syncTeamData(); // Fonction supprim√©e - synchronisation g√©r√©e dans loadTeamGameData()

// Demander l'aide pour la localisation d'un checkpoint sp√©cifique
async function requestLocationHelpFor(checkpointId) {
    if (!firebaseService || !currentTeamId) {
        showNotification('Erreur: service non disponible', 'error');
        return;
    }
    
    try {
        const checkpoint = GAME_CONFIG.checkpoints.find(cp => cp.id === checkpointId);
        const checkpointName = checkpoint ? checkpoint.name : `Point ${checkpointId}`;
        const message = `L'√©quipe ${currentTeam?.name || 'inconnue'} demande la localisation de "${checkpointName}".`;
        
        await firebaseService.createHelpRequest(
            currentTeamId,
            checkpointId,
            'location',
            message
        );
        
        showNotification(`üìç Demande de localisation envoy√©e pour "${checkpointName}"`, 'success');
        
        // Actualiser l'interface
        updateUI();
        
    } catch (error) {
        console.error('‚ùå Erreur demande d\'aide localisation:', error);
        showNotification('Erreur lors de l\'envoi de la demande', 'error');
    }
}

// Demander l'aide pour r√©soudre une √©nigme sp√©cifique
async function requestRiddleHelpFor(checkpointId) {
    if (!firebaseService || !currentTeamId) {
        showNotification('Erreur: service non disponible', 'error');
        return;
    }
    
    try {
        const checkpoint = GAME_CONFIG.checkpoints.find(cp => cp.id === checkpointId);
        const checkpointName = checkpoint ? checkpoint.name : `Point ${checkpointId}`;
        const message = `L'√©quipe ${currentTeam?.name || 'inconnue'} demande l'aide pour l'√©nigme "${checkpointName}".`;
        
        await firebaseService.createHelpRequest(
            currentTeamId,
            checkpointId,
            'riddle',
            message
        );
        
        showNotification(`üß© Demande d'aide envoy√©e pour l'√©nigme "${checkpointName}"`, 'success');
        
        // Actualiser l'interface
        updateUI();
        
    } catch (error) {
        console.error('‚ùå Erreur demande d\'aide √©nigme:', error);
        showNotification('Erreur lors de l\'envoi de la demande', 'error');
    }
}

// Anciennes fonctions d'aide supprim√©es - remplac√©es par les fonctions sp√©cifiques par checkpoint
syncCheckpoints();

console.log('‚úÖ Script du jeu de piste charg√© avec succ√®s !');
